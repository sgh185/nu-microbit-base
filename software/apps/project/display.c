/*
 * display.c
 *
 * LED matrix display implementation
 */ 
#include "display.h"
#include "font.h"
#include "utils.h"

APP_TIMER_DEF(switch_timer);
APP_TIMER_DEF(display_timer);

#define ROW_SIZE 5
#define COL_SIZE 5

#define MAX_CHARS 4
#define NUM_DIGITS 10

/*
 * ---------- Globals ----------
 */ 
bool turn_off_after_display = false ;
uint8_t display_buffer[MAX_CHARS] = { 0, 0, 0, 0 } ;
uint8_t curr_num_chars_to_display = 0 ;
uint8_t next_char_idx_to_display = 0 ;
uint8_t digits_to_ascii[NUM_DIGITS] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57 } ;

// 5x5 Font
// Adapted from https://github.com/ChrisG0x20/five-pixel-font

uint8_t font[128][5] = {
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x00,},
    {0x04,0x04,0x04,0x00,0x04,},
    {0x0A,0x0A,0x00,0x00,0x00,},
    {0x0A,0x1F,0x0A,0x1F,0x0A,},
    {0x1E,0x05,0x0E,0x14,0x0F,},
    {0x13,0x0B,0x04,0x1A,0x19,},
    {0x04,0x0A,0x04,0x0A,0x14,},
    {0x04,0x02,0x00,0x00,0x00,},
    {0x08,0x04,0x04,0x04,0x08,},
    {0x04,0x08,0x08,0x08,0x04,},
    {0x15,0x0E,0x1F,0x0E,0x15,},
    {0x00,0x04,0x0E,0x04,0x00,},
    {0x00,0x00,0x00,0x04,0x02,},
    {0x00,0x00,0x0E,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x04,},
    {0x10,0x08,0x04,0x02,0x01,},
    {0x0E,0x19,0x15,0x13,0x0E,},
    {0x04,0x06,0x04,0x04,0x0E,},
    {0x0C,0x12,0x08,0x04,0x1E,},
    {0x06,0x08,0x04,0x08,0x06,},
    {0x0C,0x0A,0x1E,0x08,0x08,},
    {0x0E,0x02,0x06,0x08,0x06,},
    {0x04,0x02,0x07,0x09,0x06,},
    {0x1E,0x10,0x08,0x04,0x04,},
    {0x06,0x09,0x06,0x09,0x06,},
    {0x06,0x09,0x0E,0x08,0x08,},
    {0x00,0x04,0x00,0x04,0x00,},
    {0x00,0x04,0x00,0x04,0x02,},
    {0x08,0x04,0x02,0x04,0x08,},
    {0x00,0x0E,0x00,0x0E,0x00,},
    {0x02,0x04,0x08,0x04,0x02,},
    {0x06,0x08,0x04,0x00,0x04,},
    {0x0E,0x10,0x16,0x15,0x0E,},
    {0x0E,0x11,0x1F,0x11,0x11,},
    {0x0F,0x11,0x0F,0x11,0x0F,},
    {0x1E,0x01,0x01,0x01,0x1E,},
    {0x0F,0x11,0x11,0x11,0x0F,},
    {0x1F,0x01,0x0F,0x01,0x1F,},
    {0x1F,0x01,0x0F,0x01,0x01,},
    {0x1E,0x01,0x19,0x11,0x1E,},
    {0x11,0x11,0x1F,0x11,0x11,},
    {0x0E,0x04,0x04,0x04,0x0E,},
    {0x1C,0x08,0x08,0x09,0x06,},
    {0x09,0x05,0x03,0x05,0x09,},
    {0x01,0x01,0x01,0x01,0x0F,},
    {0x11,0x1B,0x15,0x11,0x11,},
    {0x11,0x13,0x15,0x19,0x11,},
    {0x0E,0x11,0x11,0x11,0x0E,},
    {0x0F,0x11,0x0F,0x01,0x01,},
    {0x0E,0x11,0x11,0x09,0x16,},
    {0x0F,0x11,0x0F,0x05,0x09,},
    {0x1E,0x01,0x0E,0x10,0x0F,},
    {0x1F,0x04,0x04,0x04,0x04,},
    {0x11,0x11,0x11,0x11,0x0E,},
    {0x11,0x11,0x11,0x0A,0x04,},
    {0x11,0x11,0x15,0x15,0x0A,},
    {0x11,0x0A,0x04,0x0A,0x11,},
    {0x11,0x0A,0x04,0x04,0x04,},
    {0x0E,0x08,0x04,0x02,0x0E,},
    {0x0E,0x02,0x02,0x02,0x0E,},
    {0x01,0x02,0x04,0x08,0x10,},
    {0x0E,0x08,0x08,0x08,0x0E,},
    {0x04,0x0A,0x00,0x00,0x00,},
    {0x00,0x00,0x00,0x00,0x1F,},
    {0x04,0x08,0x00,0x00,0x00,},
    {0x00,0x0E,0x09,0x09,0x16,},
    {0x01,0x07,0x09,0x09,0x07,},
    {0x00,0x0C,0x02,0x02,0x0C,},
    {0x08,0x08,0x0E,0x09,0x0E,},
    {0x00,0x04,0x0A,0x06,0x0C,},
    {0x08,0x04,0x0E,0x04,0x04,},
    {0x0C,0x0A,0x0C,0x08,0x06,},
    {0x02,0x02,0x0E,0x12,0x12,},
    {0x04,0x00,0x04,0x04,0x04,},
    {0x08,0x00,0x08,0x0A,0x04,},
    {0x02,0x02,0x0A,0x06,0x0A,},
    {0x04,0x04,0x04,0x04,0x04,},
    {0x00,0x0B,0x15,0x11,0x11,},
    {0x00,0x06,0x0A,0x0A,0x0A,},
    {0x00,0x04,0x0A,0x0A,0x04,},
    {0x00,0x06,0x0A,0x06,0x02,},
    {0x00,0x0C,0x0A,0x0C,0x08,},
    {0x00,0x0A,0x06,0x02,0x02,},
    {0x00,0x0C,0x04,0x08,0x0C,},
    {0x00,0x0E,0x04,0x04,0x08,},
    {0x00,0x12,0x12,0x12,0x0C,},
    {0x00,0x0A,0x0A,0x0A,0x04,},
    {0x00,0x11,0x15,0x15,0x0A,},
    {0x00,0x0A,0x04,0x04,0x0A,},
    {0x00,0x0A,0x0A,0x04,0x02,},
    {0x00,0x0C,0x08,0x04,0x0C,},
    {0x08,0x04,0x06,0x04,0x08,},
    {0x04,0x04,0x00,0x04,0x04,},
    {0x02,0x04,0x0C,0x04,0x02,},
    {0x00,0x0A,0x05,0x00,0x00,},
    {0x1F,0x11,0x11,0x11,0x1F,},
};

uint8_t ROWs[ROW_SIZE] = { 
    LED_ROW1, 
    LED_ROW2, 
    LED_ROW3, 
    LED_ROW4, 
    LED_ROW5
};	

uint8_t COLs[COL_SIZE] = { 
    LED_COL1, 
    LED_COL2, 
    LED_COL3, 
    LED_COL4, 
    LED_COL5
};	

bool led_state[ROW_SIZE][COL_SIZE] = {{false}};
uint8_t cur_row_handled = ROW_SIZE - 1;


/*
 * ---------- Methods ---------- 
 */
static void ___clear_led_matrix(void)
{
    /*
     * Clear "led_state" so displays are blank 
     */
    memset(led_state, 0, sizeof(led_state));
    return;
}


static void __display_leds_callback(void *state)
{
    /*
     * TOP --- Display the next character in the global buffer.
     *
     * Callback for timer that performs LED displays
     */ 

    /*
     * Reset the current row
     */
    nrf_gpio_pin_write(ROWs[cur_row_handled], 0);


    /*
     * Set the next row to handle
     */ 
    cur_row_handled = ((cur_row_handled + 1) % ROW_SIZE);


    /*
     * Individually turn off leds by column by
     * iterating over the led_state
     *
     * NOTE --- Column pin high turns OFF LED
     */ 
    for (uint8_t i = 0 ; i < COL_SIZE ; i++)
	nrf_gpio_pin_write(
	    COLs[i], 
	    !(led_state[cur_row_handled][i])
	);


    /*
     * Turn on the leds for the next row
     */ 
    nrf_gpio_pin_write(ROWs[cur_row_handled], 1);


    return;
}


static void ___set_next_char_to_display(uint8_t num)
{
    /*
     * TOP --- Decode each entry based on font[@num], set 
     * the led_state accordingly
     */ 
    for (uint8_t row = 0 ; row < ROW_SIZE ; row++)
	for (uint8_t col = 0 ; col < ROW_SIZE ; col++)
	    led_state[row][col] = __get_bit(font[num][row], col);


    return;
}


static void __switch_char_callback(void *state)
{
    /*
     * TOP --- Display the characters in the global "display_buffer"
     *
     * Callback handler for timer that switches characters
     * according to the buffer
     */

    /*
     * Clear the matrix if there's no more characters to 
     * display, if @clear_after_display allows it
     */     
    if (next_char_idx_to_display == curr_num_chars_to_display) 
    {
	if (turn_off_after_display) ___clear_led_matrix();
	return;
    }


    /*
     * Setup next character to display, update state
     *
     * NOTE --- Make operation atomic
     */ 
    ___set_next_char_to_display(display_buffer[next_char_idx_to_display]);
    next_char_idx_to_display++; 

    
    return;
}


void set_up_new_display (
    uint8_t val, 
    uint8_t len,
    bool convert_to_ascii,
    bool clear_after_display
)
{
    /*
     * TOP 
     *
     * Place @val within the global "display_buffer" and 
     * set @len number of chars to display. 
     *
     * Sets all global variables necessary for display
     *
     * @convert_to_ascii determines whether @val needs 
     * to be split into an array of ASCII reps first
     */ 

    /*
     * If @convert_to_ascii is not set, assume that @val 
     * is a single ASCII value (sanity check @len)
     *
     * NOTE --- Make modification atomic
     */ 
    if (!convert_to_ascii)
    {
	assert(
	    true
	    && (len == 1) 
	    && "set_up_new_display: Not converting, but expecting multiple additions!"
	);
	
	__disable_irq();
	display_buffer[0] = val;
	curr_num_chars_to_display = len;
	next_char_idx_to_display = 0;
	turn_off_after_display = clear_after_display;
	__enable_irq();

	return;
    }


    /*
     * Convert the digits of @val to ASCII and store the 
     * contents into the display buffer. Sanity check 
     * @val and @len prior
     *
     * NOTE --- Make modification atomic
     */ 
    assert(len <= MAX_CHARS);
    uint8_t remainder = val;

    __disable_irq();
    curr_num_chars_to_display = len;
    next_char_idx_to_display = 0;
    turn_off_after_display = clear_after_display;
    for (int i = len - 1 ; i >= 0 ; i--)
    {
	uint8_t digit = remainder % 10;
	remainder /= 10;
	display_buffer[i] = digits_to_ascii[digit];
    }
    __enable_irq();


    return;
}


void set_up_leds(void)
{
    /*
     * Set up LED matrix
     */
    nrf_gpio_pin_dir_set(LED_COL1, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_COL2, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_COL3, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_COL4, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_COL5, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_ROW1, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_ROW2, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_ROW3, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_ROW4, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_dir_set(LED_ROW5, NRF_GPIO_PIN_DIR_OUTPUT);
    nrf_gpio_pin_clear(LED_COL1);
    nrf_gpio_pin_clear(LED_COL2);
    nrf_gpio_pin_clear(LED_COL3);
    nrf_gpio_pin_clear(LED_COL4);
    nrf_gpio_pin_clear(LED_COL5);
    nrf_gpio_pin_clear(LED_ROW1);
    nrf_gpio_pin_clear(LED_ROW2);
    nrf_gpio_pin_clear(LED_ROW3);
    nrf_gpio_pin_clear(LED_ROW4);
    nrf_gpio_pin_clear(LED_ROW5);

    
    /*
     * Set up timers
     */ 
    app_timer_create(&display_timer, APP_TIMER_MODE_REPEATED, __display_leds_callback);
    app_timer_create(&switch_timer, APP_TIMER_MODE_REPEATED, __switch_char_callback);
    app_timer_start(display_timer, HZ(500.0), NULL);
    app_timer_start(switch_timer, HZ(3.0), NULL);


    return;
}
